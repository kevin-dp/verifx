trait OT[State, Op] {
  // Transforms incoming operation `x`
  // according to existing operation `y`
  def transform(x: Op, y: Op): Op

  // Applies operation `op` on `state`
  def apply(state: State, op: Op): State

  // Checks if operation `op` can be executed on `state`
  def enabled(op: Op, state: State): Boolean = true

  // Checks that two concurrent operations are compatible
  // i.e. that they can occur in practice.
  // For example, Ellis' uses the site identifier as priority for operations generated by that site.
  // Hence, we know that concurrent operations must always have different priorities
  // (otherwise they were generate by the same site and thus not concurrent)
  def compatible(x: Op, y: Op): Boolean = true

  // Condition C1 for transformation functions expresses "semantic equivalence between two sequences".
  // See: "Proving Correctness of Transformation Functions in Real-Time Groupware"
  // by Abdessamad Imine, Pascal Molli, Gérald Oster and Michaël Rusinowitch
  proof C1 {
    forall (opI: Op, opJ: Op, st: State) {
      (this.enabled(opI, st) && this.enabled(opJ, st) && this.compatible(opI, opJ)) =>:
        (this.apply(this.apply(st, opI), this.transform(opJ, opI)) == this.apply(this.apply(st, opJ), this.transform(opI, opJ)))
    }
  }

  // Condition C2 for transformation functions expresses "syntactic equivalence between two sequences".
  // See: "Proving Correctness of Transformation Functions in Real-Time Groupware"
  // by Abdessamad Imine, Pascal Molli, Gérald Oster and Michaël Rusinowitch
  proof C2 {
    forall (opI: Op, opJ: Op, opK: Op, st: State) {
      (this.enabled(opI, st) && this.enabled(opJ, st) && this.enabled(opK, st) &&
       this.compatible(opI, opJ) && this.compatible(opJ, opK) && this.compatible(opI, opK)) =>:
        (this.transform(this.transform(opK, opI), this.transform(opJ, opI)) == this.transform(this.transform(opK, opJ), this.transform(opI, opJ)))
    }
  }

  proof compatibleCommutes {
    forall (x: Op, y: Op) {
      this.compatible(x, y) == this.compatible(y, x)
    }
  }
}