import be.vub.crdtproofs.lemmas.CmRDT
import be.vub.crdtproofs.lemmas.CmRDTProof1
import be.vub.crdtproofs.LamportClock

object Op {
  enum RegOp[V] {
    Assign(x: V)
  }

  enum RegMsg[V] {
    AssignMsg(x: V, timestamp: LamportClock)
  }
}

class OpBasedLWWRegister[V](myClock: LamportClock, value: V, stamp: LamportClock) extends CmRDT[RegOp[V], RegMsg[V], OpBasedLWWRegister[V]] {
  // Replicas must have unique IDs
  override def compatibleS(that: OpBasedLWWRegister[V]) = {
    this.myClock.replica != that.myClock.replica
  }

  def assign(x: V): RegMsg[V] = {
    val time = this.myClock.increment()
    new AssignMsg(x, time)
  }

  def assignDownstream(x: V, timestamp: LamportClock) = {
    // Update our clock if the operation was generated by us
    val newClock = if (this.myClock.replica == timestamp.replica) timestamp else this.myClock
    if (this.stamp.smaller(timestamp))
      new OpBasedLWWRegister(newClock, x, timestamp)
    else
      new OpBasedLWWRegister(newClock, this.value, this.stamp) // keep the value since its timestamp is bigger (or equal)
  }

  def prepare(op: RegOp[V]) = op match {
    case Assign(x) => this.assign(x)
  }

  def effect(op: RegMsg[V]) = op match {
    case AssignMsg(x, timestamp) => this.assignDownstream(x, timestamp)
  }

  override def equals(that: OpBasedLWWRegister[V]) = {
    this.value == that.value &&
    this.stamp == that.stamp
  }
}

object OpBasedLWWRegister extends CmRDTProof1[RegOp, RegMsg, OpBasedLWWRegister]
