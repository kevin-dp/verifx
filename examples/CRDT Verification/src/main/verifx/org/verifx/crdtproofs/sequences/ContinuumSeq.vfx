import org.verifx.crdtproofs.lemmas.CmRDT
import org.verifx.crdtproofs.lemmas.CmRDTProof2
import org.verifx.crdtproofs.sets.USet
import org.verifx.crdtproofs.LamportClock

/*
 * Implementation of a sequence based on the continuum,
 * as described in Specification 20 in "A Comprehensive Study of CRDTs".
 * The sequence is parametric in the type of the elements and the type of the identifiers.
 * Hence, the class constructor takes a `smaller` function that compares identifiers,
 * and an `allocateIdentifierBetween` function that allocates identifiers.
 *
 * The implementation slightly differs from Spec 20 for the following reasons:
 * - Spec. 20 assumes an oracle `allocateIdentifierBetween(a, c)` which generates IDs such that:
 *    1) the resulting ID, say b, is between `a` and `c`, i.e. a < b < c
 *    2) the identifier is globally unique,
 *       i.e. if the same replica inserts the same element at the same position multiple times
 *            it should get different IDs every time
 *            AND if two replicas insert the same element at the same position the resulting IDs should be different.
 *            AND the generated IDs should exhibit a total order.
 * - However, in VeriFx, functions are deterministic.
 *   So, multiple identical calls to `allocateIdentifierBetween(a, c)` will generate the same identifier.
 *   Hence, in our implementation every replica keeps a unique Lamport Clock.
 *   Inserted elements are tagged with a `UniqueTag` that comprises a Lamport Clock and the (partially ordered) identifier.
 *   The resulting tags are 1) globally unique, and 2) totally ordered.
 *   The tags are globally unique because we use Lamport Clocks.
 *   They are totally ordered because either one of the identifiers is smaller,
 *   or if the identifiers generated by `allocateIdentifierBetween` are incomparable
 *   than they are totally ordered using their Lamport Clocks.
 * - Since our implementation guarantees uniqueness and total ordering
 *   the identifier allocation function can be as simple as computing an average:
 *   allocateIdentifierBetween(a, c) = (a + c) / 2
 */

class UniqueTag[ID](clock: LamportClock, elemId: ID)

class Element[V, ID](value: V, identifier: UniqueTag[ID])

object Op {
  enum SeqOp[V, ID] {
    AddBetween(a: Element[V, ID], b: V, c: Element[V, ID]) |
    Remove(e: Element[V, ID])
  }

  enum SeqMsg[V, ID] {
    AddBetweenMsg(e: Element[V, ID]) | RemoveMsg(e: Element[V, ID])
  }
}

class ContinuumSeq[V, ID](clock: LamportClock,
                          smaller: (ID, ID) => Boolean,
                          allocateIdentifierBetween: (ID, ID) => ID,
                          elements: USet[Element[V, ID]] = new USet[Element[V, ID]]()) extends CmRDT[SeqOp[V, ID], SeqMsg[V, ID], ContinuumSeq[V, ID]] {

  override def reachable() = {
    this.clock.counter >= 0 &&
    // it cannot be that we have inserted an element with a timestamp that is later than our time now
    /*
    this.elements.forall((e: Element[V, ID]) => {
      (e.identifier.clock.replica == this.clock.replica) =>: (e.identifier.clock.counter < this.clock.counter)
    }) && */
    forall (x: ID, y: ID) {
      this.smaller(x, y) =>: {
        val z = this.allocateIdentifierBetween(x, y)
        // The identifier allocation function should return an identifier that is between the provided IDs
        this.smaller(x, z) && this.smaller(z, y)
      }
    }
  }

  override def compatibleS(that: ContinuumSeq[V, ID]) = {
    // Replicas have unique IDs
    this.clock.replica != that.clock.replica &&
    // Replicas should use the same "smaller than" comparator
    this.smaller == that.smaller &&
    this.allocateIdentifierBetween == that.allocateIdentifierBetween
  }

  private def getElement(msg: SeqMsg[V, ID]) = msg match {
    case AddBetweenMsg(e) => e
    case RemoveMsg(e) => e
  }

  // Since every element gets a unique tag it cannot be that 2 concurrent insertions have the same tag.
  // Furthermore, it also can't be that you add an element with a unique tag x, and concurrently remove that same element
  // (this is not possible because you can only remove an element once you have observed it).
  // Finally, it is possible to have 2 concurrent removals of the same element.
  override def compatible(x: SeqMsg[V, ID], y: SeqMsg[V, ID]) = x match {
    case AddBetweenMsg(e1) => {
      y match {
        case AddBetweenMsg(e2) => e1.identifier.clock.replica != e2.identifier.clock.replica // there cannot be concurrent adds coming from the same replica
        case RemoveMsg(e2) => e1.identifier != e2.identifier // cannot remove an element before observing it
      }
    }
    case RemoveMsg(e1) => {
      y match {
        case AddBetweenMsg(e2) => e1.identifier != e2.identifier // cannot remove an element before observing it
        case RemoveMsg(_) => true
      }
    }
  }

  def lookup(e: Element[V, ID]) =
    this.elements.lookup(e)

  def preBefore(x: Element[V, ID], y: Element[V, ID]) =
    this.lookup(x) && this.lookup(y)

  def before(x: Element[V, ID], y: Element[V, ID]) = {
    val lt = this.smaller
    // There must be a total order between all unique tags
    // tag1 < tag2 if its element identifier is smaller,
    // or, if the identifiers are not comparable
    // then we compare the lamport clocks
    lt(x.identifier.elemId, y.identifier.elemId) || // TODO: check why we don't get an error if we use y.identifier
    (!lt(y.identifier.elemId, x.identifier.elemId) &&
     // total order of lamport clocks
     x.identifier.clock.smaller(y.identifier.clock))
  }

  def preAddBetween(a: Element[V, ID], b: V, c: Element[V, ID]) = {
    this.lookup(a) && this.lookup(c) && this.before(a, c) //&&
    // Identifiers are unique so it cannot be that the identifier for `b` is already in the set
    //this.elements.forall((e: Element[V, ID]) => e.identifier != this.allocateIdentifierBetween(a.identifier, c.identifier))
  }

  // allocateIdentifierBetween(a, c) should return a unique identifier that is between a and c
  // each time it is called it should return a new unique identifier
  // since functions are deterministic, we need to add a parameter that represents the time at which it is called
  // allocateIdentifierBetween(a, c, time), now if you call it twice with the same `a` and `c` but a different time
  // it should return a different identifier.
  // And, different replicas should return

  // Inserts `b` between `a` and `c`
  // corresponds to the downstream `addBetween` operation from Specification 20
  def addBetween(a: Element[V, ID], b: V, c: Element[V, ID]) = {
    //val newClock = this.clock.increment()
    val id = this.allocateIdentifierBetween(a.identifier.elemId, c.identifier.elemId)
    val uniqueTag = new UniqueTag(this.clock, id)
    new AddBetweenMsg(new Element(b, uniqueTag))
  }

  /*
  // We add a downstream precondition on `add` which encodes assumptions about the delivery order of messages
  // This downstream precondition is not present in the CRDT paper because they assume causal order delivery.
  // Here, we explicitly need to encode causal order delivery.
  def preAddBetweenDownstream(e: Element[V, ID]) = {
    // If this add operation was generated by us,
    // the element must carry our clock
    if (e.identifier.clock.replica == this.clock.replica)
      e.identifier.clock == this.clock
    else
      true
      /*
      // Encodes the assumption of causal order delivery:
      // the incoming element `e` must have a clock that is bigger than the elements
      // we observed coming from the same replica.
      this.elements.forall((x: Element[V, ID]) => {
        (e.identifier.clock.replica == x.identifier.clock.replica) =>:
          (x.identifier.clock.counter < e.identifier.clock.counter)
      })
      */
  }
  */

  def addBetweenDownstream(e: Element[V, ID]) = {
    // Increment our clock if this update came from us
    val newClock = if (e.identifier.clock.replica == this.clock.replica) this.clock.increment() else this.clock

    new ContinuumSeq(
      newClock,
      this.smaller,
      this.allocateIdentifierBetween,
      this.elements.add(e)
    )
  }

  def preRemove(e: Element[V, ID]) =
    this.lookup(e)

  def remove(e: Element[V, ID]) =
    new RemoveMsg(e)

  def removeDownstream(e: Element[V, ID]) = {
    new ContinuumSeq(
      this.clock,
      this.smaller,
      this.allocateIdentifierBetween,
      this.elements.remove(e)
    )
  }

  override def enabledSrc(op: SeqOp[V, ID]) = op match {
    case AddBetween(a, b, c) => this.preAddBetween(a, b, c)
    case Remove(e) => this.preRemove(e)
  }

  /* // Only needed if we make `reachable` more precise by saying the clocks of our added elements
     // must be smaller than our current clock
  override def enabledDown(msg: SeqMsg[V, ID]) = msg match {
    case AddBetweenMsg(e) => this.preAddBetweenDownstream(e)
    case RemoveMsg(e) => true // `remove` has no downstream precondition
  }
  */

  def prepare(op: SeqOp[V, ID]) = op match {
    case AddBetween(a, b, c) => this.addBetween(a, b, c)
    case Remove(e) => this.remove(e)
  }

  def effect(msg: SeqMsg[V, ID]) = msg match {
    case AddBetweenMsg(b) => this.addBetweenDownstream(b)
    case RemoveMsg(e) => this.removeDownstream(e)
  }

  override def equals(that: ContinuumSeq[V, ID]) = {
    this.smaller == that.smaller &&
    this.elements == that.elements
  }
}

object ContinuumSeq extends CmRDTProof2[SeqOp, SeqMsg, ContinuumSeq]
