import org.verifx.crdtproofs.lemmas.CmRDT
import org.verifx.crdtproofs.lemmas.CmRDTProof2

/*
 * Implementation of a unique identifier.
 * Keeps a replica ID (which must be unique!) and a counter that is local to the replica.
 */
class Tag[ID](replica: ID, counter: Int)

/*
 * Operation-based implementation of an OR-Set.
 * Follows Specification 15 from the "Comprehensive Study of CRDTs".
 */

object Op {
  enum SetOp[V, ID] {
    Add(e: V) | Remove(e: V)
  }

  enum SetMsg[V, ID] {
    AddMsg(e: V, tag: Tag[ID]) | RemoveMsg(e: V, tags: Set[Tag[ID]])
  }
}

class OpBasedORSet[V, ID](myID: ID,
                          counter: Int = 0,
                          elements: Map[V, Set[Tag[ID]]] = new Map[V, Set[Tag[ID]]]) extends CmRDT[SetOp[V, ID], SetMsg[V, ID], OpBasedORSet[V, ID]] {

  def lookup(e: V) =
    this.elements.getOrElse(e, new Set[Tag[ID]]).nonEmpty()

  def add(e: V): SetMsg[V, ID] =
    new AddMsg(e, new Tag(this.myID, this.counter + 1))

  def addDownstream(e: V, tag: Tag[ID]) = {
    // Update our counter if the operation was generated by us
    val newCounter = if (tag.replica == this.myID) tag.counter else this.counter

    val tags = this.elements.getOrElse(e, new Set[Tag[ID]])
    val newTags = tags.add(tag)

    new OpBasedORSet(
      this.myID,
      newCounter,
      this.elements.add(e, newTags)
    )
  }

  def preRemove(e: V) = this.lookup(e)

  def remove(e: V): SetMsg[V, ID] =
    new RemoveMsg[V, ID](e, this.elements.getOrElse(e, new Set[Tag[ID]]))

  def removeDownstream(e: V, tags: Set[Tag[ID]]) = {
    val observedTags = this.elements.getOrElse(e, new Set[Tag[ID]]) // fetch the tags for this element
    val newTags = observedTags.diff(tags) // remove the tags passed to this method
    val newElements = this.elements.add(e, newTags) // create a new updated map from elements to their tags

    new OpBasedORSet(
      this.myID,
      this.counter,
      newElements
    )
  }

  override def enabledSrc(op: SetOp[V, ID]) = op match {
    case Add(e) => true // `add` has no source precondition
    case Remove(e) => this.preRemove(e)
  }

  override def compatibleS(that: OpBasedORSet[V, ID]) = {
    this.myID != that.myID // replicas have unique IDs
  }

  // Compatible encodes that a remove operation cannot remove a concurrently added element
  // because every element is added with a unique tag (so it cannot be removed before having observed it)
  override def compatible(x: SetMsg[V, ID], y: SetMsg[V, ID]) = x match {
    case AddMsg(_, tag) => {
      y match {
        case AddMsg(_, _) => true // tag1 != tag2
        case RemoveMsg(_, tags) => !tags.contains(tag) // since tags are unique, it is impossible for a remove to remove a tag that is added concurrently (because it has not yet observed it)
      }
    }
    case RemoveMsg(_, tags) => {
      y match {
        case AddMsg(_, tag) => !tags.contains(tag)
        case RemoveMsg(_, _) => true
      }
    }
  }

  def prepare(op: SetOp[V, ID]) = op match {
    case Add(e) => this.add(e)
    case Remove(e) => this.remove(e)
  }

  def effect(msg: SetMsg[V, ID]) = msg match {
    case AddMsg(e, tag) => this.addDownstream(e, tag)
    case RemoveMsg(e, tags) => this.removeDownstream(e, tags)
  }

  override def equals(that: OpBasedORSet[V, ID]) = {
    this.elements == that.elements
  }
}

object OpBasedORSet extends CmRDTProof2[SetOp, SetMsg, OpBasedORSet]
